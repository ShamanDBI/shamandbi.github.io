========
Building
========

This project is divided into two parts, the core library which has all the core features. To integerate this in your project you need to first build the code library which is show in the next section.

You can also refer to the scripts/build.sh file.

Building Core Library
=====================

.. code-block:: console

    mkdir -p builds
    cmake -S . -B builds/build_lib
    cmake --build ./builds/build_lib
    cmake --install ./builds/build_lib --prefix ./builds/shaman_lib

.. _example_systrace:

Example #1 : Syscall Tracer
===========================

This exmaple demonstrates different syscall related API's which the project offers and how to use them.

Build
-----

.. code-block:: console

    cmake -S ./examples/syscall_tracer -B ./builds/syscall_tracer
    cmake --build ./builds/syscall_tracer

.. _example_code_cov:

Running
-------

.. code-block:: console

    ./builds/syscall_tracer/syscall_tracer -h


Example #2 : Binary Code Coverage
=================================

This project demonstrates how to collect binary code coverage by placing breakpoints at every basic block of the module you want to trace. The addresses of all the basic blocks are identified using Ghidra scripts.

This application also showcases an interesting concept involving shared memory between a producer and a consumer process. The debugger acts as the producer process, continuously writing the execution trace to shared memory. The consumer process listens to the shared buffer and processes the coverage data. This design is inspired by a blog.

The advantage of this design is speed and extensibility. Writing to memory is significantly faster than dumping data to a file. By offloading file writing to another process, the coverage collection remains efficient. Additionally, this data can be sent over a socket, which is useful for IoT devices with limited memory that need to collect extensive traces.

Build
-----

This application will produce two binaries *binary_coverage_app* and *binary_coverage_consumer* in *./builds/binary_coverage_app* directory.

.. code-block:: console

    mkdir builds

    cmake -S ./examples/binary_coverage -B ./builds/binary_coverage_app
    cmake --build ./builds/binary_coverage_app

Running
-------

You can also refer to the script *examples/binary_coverage/run.sh*, which contains all the steps mentioned below in a shell script.

#. First extract the basic block address of module you are interested to trace using Ghidra script.

    .. code-block:: console

        # $GHIDRA_HOME   - path to the ghidra home directory
        # target_binary  - application binary for which you want to generate gather code coverage
        # project output - project file created by ghidra will be saved in this directory
        # project name   - name of the project in ghidra
        # script_path    - path which has all the ghidra scripts, you can set this value to <shaman_dir>/script
        $GHIDRA_HOME/support/analyzeHeadless <project output> <project_name> -import <target_binary> -scriptPath <script_path> -postscript ghidra_bb_expoter.py <output_file>

        # Example command
        $GHIDRA_HOME/support/analyzeHeadless shaman_ghidra_projects test_target -import builds/test_target/bin/test_target -scriptPath $(pwd)/script/ -postscript ghidra_bb_expoter.py output_test

        # you can also refer to script/generate-ghidra-bb.sh file

    This will generate a file which has all the basic block address of the module in **output_test.bb** file. You have to pass this file to the binary_coverage application.

#. Execute the target application with the following command.

    .. code-block:: console

        # -l -> will log the application debug information in the app.log file
        # --cov-basic-block -> basic block file generated by the ghidra script
        # --pipe-id -> shared memory id which will be used to communicate between the producer and consumer
        # -e -> target application which you want to trace

        builds/binary_coverage_app/binary_coverage -l app.log --cov-basic-block ./output_test.bb --pipe-id 51900 -e ./test_target/bin/test_target 1
    
    This will start the application and start collecting the coverage. The coverage will be written to the shared memory with pipe-id 51900. You need to use the same pipe-id in the consumer application.

#. Then start another terminal which has the coverage consume application with the following command.

    .. code-block:: console
        
        # starts the binary consumer with same pipe-id
        builds/binary_coverage_app/binary_coverage_consumer 51900
    
    This will start the consumer application which will start reading the shared memory and process the coverage.

    If you want to do some custom processing of the coverage you can modify the consumer application. The consumer application is in the *./examples/binary_coverage/src* directory and the file name is *binary_coverage_consumer.cpp*.
    